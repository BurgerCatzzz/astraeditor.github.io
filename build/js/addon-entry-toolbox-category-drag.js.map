{"version":3,"file":"js/addon-entry-toolbox-category-drag.js","sources":["webpack://GUI/./src/addons/addons/toolbox-category-drag/userstyle.css","webpack://GUI/./src/addons/addons/toolbox-category-drag/_runtime_entry.js","webpack://GUI/./src/addons/addons/toolbox-category-drag/userscript.js"],"sourcesContent":["exports = module.exports = require(\"../../../../node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \"div[class=\\\"scratchCategoryMenuRow\\\"][data-dragger=\\\"true\\\"] > div {\\n    background: var(--ui-secondary);\\n    font-size: 0.65rem;\\n}\\n\\n[theme=\\\"dark\\\"] div[class=\\\"scratchCategoryMenuRow\\\"][data-dragger=\\\"true\\\"] > div {\\n    background: var(--ui-secondary);\\n}\", \"\"]);\n\n// exports\n","/* generated by pull.js */\nimport _js from \"./userscript.js\";\nimport _css from \"!css-loader!./userstyle.css\";\nexport const resources = {\n    \"userscript.js\": _js,\n    \"userstyle.css\": _css,\n};\n","// Toolbox Category Drag\n// By: SharkPool\nexport default async function ({ addon }) {\n    // wait for scratchblocks to be defined\n    await addon.tab.traps.getBlockly();\n\n    const COMMENT_TRAPPER_ID = \"--Category_Order_ADDON-config\";\n    const soup = \"!#%()*+,-./:;=?@[]^_`{|}~ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    \n    let categoryOrdering = undefined;\n    \n    const genUID = () => {\n        const id = [];\n        for (let i = 0; i < 20; i++) {\n            id[i] = soup.charAt(Math.random() * soup.length);\n        }\n        return id.join(\"\");\n    }\n    \n    const createSep = () => {\n        const sep = document.createElement(\"sep\");\n        sep.setAttribute(\"gap\", \"36\");\n        return sep;\n    };\n    \n    const extractCategoryID = (classList) => {\n        for (const text of classList) {\n            if (text.startsWith(\"scratchCategoryId-\")) return text.replace(\"scratchCategoryId-\", \"\");\n        }\n        return undefined;\n    }\n    \n    const ogPopulate = ScratchBlocks.Toolbox.CategoryMenu.prototype.populate;\n    ScratchBlocks.Toolbox.CategoryMenu.prototype.populate = function (...args) {\n        if (!categoryOrdering) {\n            ogPopulate.call(this, ...args);\n            return;\n        }\n        \n        const toolboxXml = args[0];\n        const children = Array.from(toolboxXml.children);\n        const categories = children.filter(e => e.tagName === \"category\");\n        \n        /* sort categories based on categoryOrdering */\n        categories.sort((a, b) => {\n            const aIndex = categoryOrdering.indexOf(a.getAttribute(\"id\"));\n            const bIndex = categoryOrdering.indexOf(b.getAttribute(\"id\"));\n            return (aIndex === -1 ? 999 : aIndex) - (bIndex === -1 ? 999 : bIndex);\n        });\n        \n        while (toolboxXml.firstChild) toolboxXml.removeChild(toolboxXml.firstChild);\n        \n        /* <sep> + <category> + <sep> + ... + <category> + <sep> */\n        toolboxXml.appendChild(createSep());\n        categories.forEach((cat) => {\n            toolboxXml.appendChild(cat);\n            toolboxXml.appendChild(createSep());\n        });\n        \n        ogPopulate.call(this, ...args);\n    };\n    \n    const ogSaveJSON = vm.toJSON;\n    vm.toJSON = function (...args) {\n        if (categoryOrdering !== undefined) saveOrdering();\n        return ogSaveJSON.call(this, ...args);\n    }\n    \n    vm.runtime.on(\"PROJECT_LOADED\", () => {\n        const storedOrder = findOrderingComment(true);\n        if (storedOrder) {\n            try {\n                categoryOrdering = JSON.parse(storedOrder);\n                setTimeout(forceRefreshToolbox, 100);\n            } catch {\n                // Blockly might not be availiable, wait until it is\n                vm.once(\"workspaceUpdate\", () => {\n                    try {\n                        categoryOrdering = JSON.parse(storedOrder);\n                        setTimeout(forceRefreshToolbox, 100);\n                    } catch {}\n                });\n            }\n        }\n    });\n    \n    function findOrderingComment(optParse) {\n        const stageTarget = vm.runtime.getTargetForStage();\n        if (!stageTarget) return undefined;\n        \n        let configComment;\n        const comments = Object.values(stageTarget.comments);\n        for (const comment of comments) {\n            if (comment.text.endsWith(COMMENT_TRAPPER_ID)) {\n                configComment = comment.text;\n                break;\n            }\n        }\n        \n        if (configComment) {\n            if (!optParse) return true;\n\n            const dataLine = configComment.split(\"\\n\").find(i => i.endsWith(COMMENT_TRAPPER_ID));\n            if (!dataLine) return undefined;\n            return dataLine.substr(0, dataLine.length - COMMENT_TRAPPER_ID.length);\n        }\n        return optParse ? undefined : false;\n    }\n    \n    function saveOrdering() {\n        if (findOrderingComment()) return;\n        \n        const stageTarget = vm.runtime.getTargetForStage();\n        if (!stageTarget) return;\n        \n        const text = `Configuration for 'Category Ordering' Addon\\nYou can move, resize, and minimize this comment, but don't edit it by hand. This comment can be deleted to remove the stored settings.\\n${JSON.stringify(categoryOrdering)}${COMMENT_TRAPPER_ID}`;\n        stageTarget.createComment(genUID(), null, text, 50, 50, 350, 170, false);\n        vm.runtime.emitProjectChanged();\n    }\n    \n    function compileNewOrder(htmlCategoryList) {\n        const orderedIDs = [];\n        for (const cat of htmlCategoryList) {\n            const id = extractCategoryID(cat.firstChild.classList);\n            if (id) orderedIDs.push(id);\n        }\n        categoryOrdering = orderedIDs;\n    }\n    \n    function forceRefreshToolbox() {\n        const workspace = ScratchBlocks.getMainWorkspace();\n        const toolbox = workspace.getToolbox();\n        if (!toolbox) return;\n        const categoryMenu = toolbox.categoryMenu_;\n        if (!categoryMenu) return;\n        if (categoryMenu.secondTable) return;\n        \n        categoryMenu.dispose();\n        categoryMenu.createDom();\n        toolbox.populate_(workspace.options.languageTree);\n        toolbox.position();\n    }\n    \n    function initDragDroper(clickEvent, blocklyToolboxDiv) {\n        const draggedCat = clickEvent.target.closest(`div[class=\"scratchCategoryMenuRow\"]`);\n        if (!draggedCat) return;\n        \n        const categoryList = blocklyToolboxDiv.querySelectorAll(`div[class*=\"scratchCategoryMenuRow\"]`);\n        \n        const rect = draggedCat.getBoundingClientRect();\n        const generalHeight = rect.height;\n        const offsetX = clickEvent.clientX - rect.left;\n        const offsetY = clickEvent.clientY - rect.top;\n        \n        const dragger = draggedCat.cloneNode(true);\n        draggedCat.style.opacity = 0.5;\n        \n        dragger.setAttribute(\"style\", `position: absolute; z-index: 99999; left: ${rect.left}px; top: ${rect.top}px; width: ${rect.width}px; pointer-events: none;`);\n        dragger.firstChild.setAttribute(\"style\", `box-shadow: #000 5px 5px 10px; border-radius: 8px;`);\n        dragger.dataset.dragger = true;\n        document.body.appendChild(dragger);\n        \n        let lastHovered = null;\n        \n        const onMouseMove = (moveEvent) => {\n            /* drag visual */\n            const newLeft = moveEvent.clientX - offsetX;\n            const newTop = moveEvent.clientY - offsetY;\n            dragger.style.left = `${newLeft}px`;\n            dragger.style.top = `${newTop}px`;\n            \n            // auto scroll if dragger is near the top/bottom\n            const scrollZoneSize = 40;\n            const bounds = blocklyToolboxDiv.getBoundingClientRect();\n            \n            if (moveEvent.clientY < bounds.top + scrollZoneSize) {\n                blocklyToolboxDiv.scrollTop -= 4;\n            } else if (moveEvent.clientY > bounds.bottom - scrollZoneSize) {\n                blocklyToolboxDiv.scrollTop += 4;\n            }\n            \n            // check if we are near any category\n            // if so, bump down everything below the dragger\n            let target;\n            for (const cat of categoryList) {\n                if (cat === draggedCat) continue;\n                const catRect = cat.getBoundingClientRect();\n                const midpointY = catRect.top + catRect.height / 2;\n                const midpointX = catRect.left + catRect.width / 2;\n                \n                const xDist = Math.abs(moveEvent.clientX - midpointX);\n                const yCheck = moveEvent.clientY < midpointY;\n                if (yCheck && xDist < 100) {\n                    target = cat;\n                    break;\n                }\n            }\n            \n            for (const cat of categoryList) cat.style.transform = \"\";\n            if (target) {\n                lastHovered = target;\n                let shifter = target;\n                while (shifter) {\n                    if (shifter === draggedCat) return;\n                    shifter.style.transform = `translateY(${generalHeight}px)`;\n                    shifter = shifter.nextSibling;\n                }\n            } else {\n                lastHovered = null;\n            }\n        };\n        const onMouseUp = () => {\n            /* cleanup */\n            document.removeEventListener(\"mousemove\", onMouseMove);\n            document.removeEventListener(\"mouseup\", onMouseUp);\n            for (const cat of categoryList) cat.style.transform = \"\";\n            draggedCat.style.opacity = \"\";\n            dragger.remove();\n            \n            // if the category drag was valid, move the category\n            if (lastHovered) {\n                const id = extractCategoryID(draggedCat.firstChild.classList);\n                draggedCat.parentNode.insertBefore(draggedCat, lastHovered);\n                \n                const newCatList = blocklyToolboxDiv.querySelectorAll(`div[class*=\"scratchCategoryMenuRow\"]`);\n                compileNewOrder(newCatList);\n                setTimeout(() => {\n                    forceRefreshToolbox();\n                    if (id) ScratchBlocks.mainWorkspace.toolbox_.setSelectedCategoryById(id);\n                }, 100);\n            }\n        };\n        \n        document.addEventListener(\"mousemove\", onMouseMove);\n        document.addEventListener(\"mouseup\", onMouseUp);\n    }\n\n    function activateBlocklyListener() {\n        /* Check for Long (500ms) Presses to not confuse with Selecting Categories */\n        const blocklyToolboxDiv = document.querySelector(`div[class*=\"blocklyToolboxDiv\"`);\n        if (!blocklyToolboxDiv) return;\n        blocklyToolboxDiv.addEventListener(\"mousedown\", (e) => {\n            const longPressTimer = setTimeout(() => initDragDroper(e, blocklyToolboxDiv), 500);\n            const cancel = () => clearTimeout(longPressTimer);\n\n            document.addEventListener(\"mouseup\", cancel, { once: true });\n            document.addEventListener(\"mouseleave\", cancel, { once: true });\n        });\n    }\n\n    let wasInEditor, inEditor;\n    ReduxStore.subscribe(() => {\n        const state = ReduxStore.getState().scratchGui;\n\n        wasInEditor = inEditor;\n        inEditor = !state.mode.isPlayerOnly;\n        if (inEditor && !wasInEditor) {\n            wasInEditor = inEditor;\n            queueMicrotask(activateBlocklyListener);\n        }\n    });\n}\n"],"mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACPA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AADA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}