{"version":3,"file":"js/addon-entry-block-pins.js","sources":["webpack://GUI/./src/addons/addons/block-pins/_runtime_entry.js","webpack://GUI/./src/addons/addons/block-pins/userscript.js"],"sourcesContent":["/* generated by pull.js */\nimport _js from \"./userscript.js\";\nexport const resources = {\n  \"userscript.js\": _js,\n};\n","// Block Pinning\n// By: SharkPool\n\nexport default async function({ addon, msg }) {\n  const Blockly = await addon.tab.traps.getBlockly();\n  const vm = addon.tab.traps.vm;\n\n  const categoryIcon = \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI3MC42OTIiIGhlaWdodD0iNzAuNjkyIiB2aWV3Qm94PSIwIDAgNzAuNjkyIDcwLjY5MiI+PHBhdGggZD0iTTAgMzUuMzQ2QzAgMTUuODI1IDE1LjgyNSAwIDM1LjM0NiAwczM1LjM0NiAxNS44MjUgMzUuMzQ2IDM1LjM0Ni0xNS44MjUgMzUuMzQ2LTM1LjM0NiAzNS4zNDZTMCA1NC44NjcgMCAzNS4zNDYiIGZpbGw9IiNjNWJmOTYiLz48cGF0aCBkPSJNNC42NTYgMzUuMzQ2YzAtMTYuOTUgMTMuNzQtMzAuNjkgMzAuNjktMzAuNjlzMzAuNjkgMTMuNzQgMzAuNjkgMzAuNjktMTMuNzQgMzAuNjktMzAuNjkgMzAuNjktMzAuNjktMTMuNzQtMzAuNjktMzAuNjkiIGZpbGw9IiNmZmY3YzIiLz48cGF0aCBkPSJNNDguOTU2IDQ0LjAwMyA1MSA1MC4wMmwtNi4wMTctMi4wNDVMMzQuMTY4IDM3LjE2Yy0xLjg3MyAxLjY1NS02LjAwNyA1LjE1MS03LjMwMyA1LjAxOS0yLjM4Ny0uMjQ0LTEuODg5LTIuOTQ3LTIuMDQ4LTUuMzc2LS4xNTgtMi40MyAxLjQ3MS0zLjQ0IDEuNDcxLTMuNDRsLTUuODc5LTUuODhhMi40NSAyLjQ1IDAgMCAxIDAtMy40NjFsNC42MzMtNC42MzNhMi40NSAyLjQ1IDAgMCAxIDMuNDYxIDBsNi4wNyA2LjA3czIuMTQ5LTIuMDAzIDMuOTAyLTJjMS43NTMuMDAyIDUuNjY0LjA3NSA1LjMyMyAyLjAxMy0uMjM1IDEuMzMyLTQuMTExIDUuOTYtNS42MzkgNy43MzV6IiBmaWxsPSIjNDQ1MjczIi8+PC9zdmc+\";\n\n  const category = document.createElementNS(\"http://www.w3.org/1999/xml\", \"category\");\n  category.setAttribute(\"name\", msg(\"pinned\"));\n  category.setAttribute(\"id\", \"pinned\");\n  category.setAttribute(\"colour\", \"#ffffff\");\n  category.setAttribute(\"secondaryColour\", \"#ffffff\");\n  category.setAttribute(\"iconURI\", categoryIcon);\n\n  const gap = document.createElementNS(\"http://www.w3.org/1999/xml\", \"sep\");\n  gap.setAttribute(\"gap\", \"36\");\n\n  let populateInit = 0; // counts up to 3, any 'populate' call while this is less than 3 will update the toolbox\n  let pins = loadPins();\n\n  const autoLoadExtPins = addon.settings.get(\"autoLoadExts\");\n\n  function findExtensionPins() {\n    const extUrls = [];\n\n    const manager = vm.extensionManager;\n    const loadedExts = manager._loadedExtensions;\n    loadedExts.keys().forEach((id) => {\n      if (pins.some(b => b.startsWith(id))) {\n        const meta = loadedExts.get(id);\n\n        if (meta.startsWith(\"extension_\")) {\n          // built-in extension\n          extUrls.push(id);\n        } else {\n          // external extension\n          const index = parseInt(meta.split(\".\")[1]);\n          extUrls.push(manager.workerURLs[index]);\n        }\n      }\n    });\n    return extUrls;\n  }\n\n  function loadPins() {\n    try {\n      const item = localStorage.getItem(\"ADDONS_BLOCK-PINS\");\n      if (!item) return [];\n\n      const testPins = JSON.parse(item);\n      if (Array.isArray(testPins.blocks) && Array.isArray(testPins.exts)) {\n        // load required extensions\n        const manager = vm.extensionManager;\n        for (const ext of testPins.exts) {\n          try {\n            const isURL = new URL(ext);\n            manager.securityManager.canLoadExtensionFromProject(ext).then(isUnsandbox => {\n              manager.loadExtensionURL(ext);\n            });\n          } catch {\n            // not a URL, must be a built-in\n            manager.loadExtensionIdSync(ext);\n          }\n        }\n        return testPins.blocks;\n      } else {\n        return [];\n      }\n    } catch {\n      console.warn(\"Malformed Block Pins!\");\n      localStorage.removeItem(\"ADDONS_BLOCK-PINS\");\n      return [];\n    }\n  }\n\n  function storePins() {\n    const requiredExtensions = autoLoadExtPins ? findExtensionPins() : [];\n    localStorage.setItem(\n      \"ADDONS_BLOCK-PINS\", JSON.stringify({\n        blocks: pins, exts: requiredExtensions\n      })\n    );\n  }\n\n  const createMenuItem = (text, enabled, callback) => {\n    // so amazing, saves like, 20 lines\n    return { text, enabled, callback };\n  };\n\n  const createLabel = (text) => {\n    const label = document.createElementNS(\"http://www.w3.org/1999/xml\", \"label\");\n    label.setAttribute(\"text\", text);\n    return label;\n  };\n\n  const specifyType = (block) => {\n    let type = block.type;\n    if (type === \"data_variable\" || type === \"data_listcontents\") {\n      type += \"||v||\" + block.getVars()[0];\n    } else if (type === \"procedures_call\") {\n      type += \"||p||\" + block.getProcCode();\n    }\n    return type;\n  };\n\n  const getBlockByType = (type, ws) => {\n    const typeMeta = type.split(\"||\");\n    const blocks = Object.values(ws.blockDB_);\n    if (typeMeta.length === 1) return blocks.find(b => b.type === type);\n    else {\n      const candidates = blocks.filter(b => b.type === typeMeta[0]);\n      for (const test of candidates) {\n        if (typeMeta[1] === \"p\") {\n          if (test.getProcCode() === typeMeta[2]) return test;\n        }\n        if (typeMeta[1] === \"v\") {\n          if (test.getVars()[0] === typeMeta[2]) return test;\n        }\n      }\n      return null;\n    }\n  };\n\n  const populateCategory = () => {\n    category.innerHTML = \"\"; // flush out blocks\n\n    if (pins.length) {\n      const flyoutWS = Blockly.mainWorkspace.getFlyout().workspace_;\n      const blocksXML = [];\n      let successes = 0;\n      for (const type of pins) {\n        const block = getBlockByType(type, flyoutWS);\n        if (block) {\n          successes++;\n          blocksXML.push(Blockly.Xml.blockToDom(block));\n        } else {\n          console.warn(\"Pins Addon -- Could not find block with type: \" + type);\n        }\n      }\n\n      if (blocksXML.length === 0) blocksXML.push(createLabel(msg(\"no_pinned_blocks\")));\n      else if (successes !== pins.length) blocksXML.push(createLabel(msg(\"some_pins_could_not_load\")));\n      category.append(...blocksXML, gap);\n    } else {\n      category.append(createLabel(msg(\"no_pinned_blocks\")), gap);\n    }\n  }\n\n  const updatePinCategory = () => {\n    populateCategory();\n    const toolbox = Blockly.mainWorkspace.getToolbox();\n    toolbox.populate_(toolbox.workspace_.options.languageTree);\n\n    storePins();\n  };\n\n  const toggleBlockPin = (block, isPinning, forceOrder) => {\n    const oldLength = pins.length;\n    const type = specifyType(block);\n    const index = pins.indexOf(type);\n\n    if (isPinning) {\n      switch (forceOrder) {\n        case \"top\":\n          pins.splice(index, 1);\n          pins = [type, ...pins];\n          break;\n        case \"bottom\":\n          pins.splice(index, 1);\n          pins.push(type);\n          break;\n        case \"category\": {\n          const toolbox = Blockly.mainWorkspace.getToolbox();\n          const flyoutWS = Blockly.mainWorkspace.getFlyout().workspace_;\n          const categories = toolbox.categoryMenu_.categories_.map(c => c.id_);\n\n          const getCategoryInd = (id) => {\n            const block = getBlockByType(id, flyoutWS);\n            let cateID = block.category_;\n            if (cateID === \"data\") cateID = \"variables\";\n            else if (cateID === \"data-lists\") cateID = \"lists\";\n            else if (cateID === null) cateID = \"myBlocks\";\n            return categories.indexOf(cateID);\n          };\n\n          pins = pins.sort((a, b) => getCategoryInd(a) - getCategoryInd(b));\n          break;\n        }\n        default:\n          if (index === -1) pins.push(type);\n      }\n    } else if (index > -1) {\n      pins.splice(index, 1);\n    }\n\n    if (oldLength !== pins.length || forceOrder) updatePinCategory();\n  };\n\n  const ogShowCtxMenu = Blockly.BlockSvg.prototype.showContextMenu_;\n  Blockly.BlockSvg.prototype.showContextMenu_ = function(e) {\n    if (this.workspace.options.readOnly || !this.contextMenu) return;\n\n    let shouldPatchClasses = false;\n\n    // Save the current block in a variable for use in closures.\n    var block = this;\n    var menuOptions = [];\n    if (this.isDeletable() && this.isMovable() && block.isInFlyout) {\n      if (pins.includes(specifyType(block))) {\n        shouldPatchClasses = true;\n        menuOptions.push(\n          createMenuItem(msg(\"move_to_top\"), true, () => toggleBlockPin(block, true, \"top\")),\n          createMenuItem(msg(\"move_to_bottom\"), true, () => toggleBlockPin(block, true, \"bottom\")),\n          createMenuItem(msg(\"organize_by_category\"), true, () => toggleBlockPin(\"\", true, \"category\")),\n          createMenuItem(msg(\"pin\"), false, () => {}),\n          createMenuItem(msg(\"unpin\"), true, () => toggleBlockPin(block, false))\n        );\n      } else {\n        menuOptions.push(\n          createMenuItem(msg(\"pin\"), true, () => toggleBlockPin(block, true)),\n          createMenuItem(msg(\"unpin\"), false, () => {})\n        );\n      }\n\n      menuOptions.push(createMenuItem(msg(\"unpin_all\"), pins.length, () => {\n        pins = [];\n        updatePinCategory();\n      }));\n    } else {\n      ogShowCtxMenu.call(this, e);\n      return;\n    }\n\n    if (this.customContextMenu) this.customContextMenu(menuOptions);\n    Blockly.ContextMenu.show(e, menuOptions, this.RTL);\n    Blockly.ContextMenu.currentBlock = this;\n\n    if (shouldPatchClasses) {\n      // since we have to patch the context meny generator, we cant use\n      // addon apis to fancify the menu. So, recreate it here:\n      const menuItems = Blockly.WidgetDiv.DIV.querySelectorAll(`div[class^=\"goog-menuitem-content\"]`);\n      /* Unpin item */\n      menuItems[3].parentNode.style.borderTop = \"1px solid rgba(0, 0, 0, 0.15)\";\n    };\n  }\n\n  const ogPopulate = Blockly.Toolbox.CategoryMenu.prototype.populate;\n  Blockly.Toolbox.CategoryMenu.prototype.populate = function(newTree) {\n    if (populateInit < 3) {\n      populateInit++;\n      setTimeout(() => {\n        // 1 second is a good buffer\n        populateCategory();\n        const toolbox = Blockly.mainWorkspace.getToolbox();\n        if (!toolbox) return;\n        toolbox.populate_(toolbox.workspace_.options.languageTree);\n      }, 1000);\n    }\n\n    newTree.insertBefore(category, newTree.firstElementChild);\n    ogPopulate.call(this, newTree);\n  }\n\n  vm.runtime.on(\"PROJECT_LOADED\", () => {\n    populateInit = 0;\n  });\n  if (!autoLoadExtPins) vm.runtime.on(\"EXTENSION_ADDED\", () => {\n    populateInit = 2;\n  });\n  vm.runtime.on(\"EXTENSION_REMOVED\", (extId) => {\n    // remove blocks in the removed extension from pins\n    pins = pins.filter((t) => !t.startsWith(extId));\n\n    populateInit = 2;\n  });\n  addon.self.addEventListener(\"disabled\", () => {\n    localStorage.removeItem(\"ADDONS_BLOCK-PINS\");\n  });\n}\n"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACJA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}