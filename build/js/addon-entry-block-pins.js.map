{"version":3,"file":"js/addon-entry-block-pins.js","sources":["webpack://GUI/./src/addons/addons/bookmark/userstyle.css","webpack://GUI/./src/addons/addons/block-pins/_runtime_entry.js","webpack://GUI/./src/addons/addons/block-pins/userscript.js","webpack://GUI/./src/addons/addons/bookmark/_runtime_entry.js","webpack://GUI/./src/addons/addons/bookmark/userscript.js","webpack://GUI/./src/addons/addons/bookmark/bookmark.svg"],"sourcesContent":["exports = module.exports = require(\"../../../../node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".sa-bookmark-button {\\n  cursor: pointer;\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n  padding: 0.2rem 0.5rem;\\n  font-family: inherit;\\n  font-size: 12px;\\n  font-weight: bold;\\n  background-color: var(--ui-white);\\n  border-width: 1px;\\n  border-style: solid;\\n  color: var(--text-primary);\\n  border-color: var(--ui-black-transparent);\\n  border-radius: 4px;\\n  transition: border-color 0.2s ease;\\n  white-space: nowrap;\\n  gap: 0.5rem;\\n  height: 1.5rem;\\n  margin-top: auto !important;\\n  margin-bottom: auto !important;\\n  margin-left: 10px;\\n}\\n\\n.sa-bookmark-button:hover {\\n  border-color: var(--motion-primary);\\n}\\n\\n.sa-bookmark-button img {\\n  display: inline-block;\\n  width: 2rem !important;\\n  height: 2rem !important;\\n}\\n\\n.sa-bookmark-button svg {\\n  width: 20px;\\n  height: 20px;\\n  color: currentColor;\\n}\\n\\n/* VSCode 布局下的书签按钮样式 */\\n[class*=\\\"tabs\\\"][class*=\\\"vscodeList\\\"] .sa-bookmark-button {\\n  width: 40px;\\n  height: 30px;\\n  font-size: 0;\\n  background-color: #00000000;\\n  border: 0;\\n  border-radius: 0 !important;\\n  margin: 0 !important;\\n  padding: 0 !important;\\n  flex-direction: column;\\n  justify-content: center;\\n  align-items: center;\\n  position: relative;\\n  margin-bottom: 10px !important;\\n}\\n\\n[class*=\\\"tabs\\\"][class*=\\\"vscodeList\\\"] .sa-bookmark-button img {\\n  width: 2rem;\\n  height: 2rem;\\n}\\n\\n/* Modal styles */\\n.sa-bookmark-modal {\\n  box-sizing: border-box;\\n  width: 700px;\\n  max-height: min(800px, 80vh);\\n  max-width: 85%;\\n  margin-top: 12vh;\\n  overflow-y: auto;\\n  margin-left: auto;\\n  margin-right: auto;\\n}\\n\\n.sa-bookmark-modal-content {\\n  padding: 1.5rem 2.25rem;\\n}\\n\\n.sa-bookmark-list {\\n  max-height: 400px;\\n  overflow-y: auto;\\n  margin-bottom: 1.5rem;\\n  border: 1px solid var(--ui-black-transparent);\\n  border-radius: 4px;\\n  padding: 0.5rem;\\n}\\n\\n.sa-bookmark-empty {\\n  text-align: center;\\n  padding: 2rem;\\n  color: var(--text-primary);\\n}\\n\\n.sa-bookmark-item {\\n  display: flex;\\n  justify-content: space-between;\\n  align-items: center;\\n  padding: 0.75rem;\\n  margin-bottom: 0.5rem;\\n  background-color: rgba(0, 0, 0, 0.05);\\n  border-radius: 4px;\\n}\\n\\n.sa-bookmark-item:last-child {\\n  margin-bottom: 0;\\n}\\n\\n.sa-bookmark-info {\\n  flex: 1;\\n  display: flex;\\n  flex-direction: column;\\n  gap: 0.25rem;\\n}\\n\\n.sa-bookmark-name {\\n  font-weight: bold;\\n  font-size: 1rem;\\n  cursor: pointer;\\n  padding: 2px 6px;\\n  border-radius: 4px;\\n  transition: background-color 0.2s;\\n}\\n\\n.sa-bookmark-name:hover {\\n  background-color: rgba(0, 0, 0, 0.05);\\n}\\n\\n.sa-bookmark-name-input {\\n  width: 100%;\\n  font-weight: bold;\\n  font-size: 1rem;\\n  padding: 2px 6px;\\n  border-radius: 0.25rem;\\n}\\n\\n.sa-bookmark-time {\\n  font-size: 0.875rem;\\n  color: var(--text-primary);\\n}\\n\\n.sa-bookmark-actions {\\n  display: flex;\\n  gap: 0.5rem;\\n}\\n\\n.sa-bookmark-action-button {\\n  padding: 0.5rem 1rem;\\n  border: none;\\n  border-radius: 4px;\\n  cursor: pointer;\\n  font-size: 0.875rem;\\n  transition: background-color 0.2s;\\n}\\n\\n.sa-bookmark-action-button:hover {\\n  opacity: 0.8;\\n}\\n\\n.sa-bookmark-delete {\\n  background-color: #ff4d4d;\\n  color: white;\\n}\\n\\n.sa-bookmark-delete:hover {\\n  background-color: #ff3333;\\n}\\n\\n.sa-bookmark-add-form {\\n  display: flex;\\n  flex-direction: column;\\n  gap: 0.75rem;\\n  padding-top: 1rem;\\n  border-top: 1px solid var(--ui-black-transparent);\\n}\\n\\n.sa-bookmark-add-form label {\\n  font-weight: bold;\\n  font-size: 0.875rem;\\n}\\n\\n.sa-bookmark-add-form input {\\n  padding: 0.5rem;\\n  border: 1px solid var(--ui-black-transparent);\\n  border-radius: 4px;\\n  font-size: 0.875rem;\\n}\\n\\n.sa-bookmark-add-form button {\\n  padding: 0.75rem;\\n  border: none;\\n  border-radius: 4px;\\n  cursor: pointer;\\n  font-weight: bold;\\n  font-size: 0.875rem;\\n  transition: background-color 0.2s;\\n}\\n\\n\\n@media (prefers-color-scheme: dark) {\\n  .sa-bookmark-button:hover {\\n    background-color: rgba(255, 255, 255, 0.1);\\n  }\\n\\n  .sa-bookmark-item {\\n    background-color: rgba(255, 255, 255, 0.05);\\n  }\\n\\n  .sa-bookmark-empty {\\n    color: rgba(255, 255, 255, 0.5);\\n  }\\n\\n  .sa-bookmark-time {\\n    color: rgba(255, 255, 255, 0.6);\\n  }\\n\\n  .sa-bookmark-add-form input {\\n    border-color: rgba(255, 255, 255, 0.2);\\n    background-color: rgba(255, 255, 255, 0.05);\\n    color: white;\\n  }\\n}\", \"\"]);\n\n// exports\n","/* generated by pull.js */\nimport _js from \"./userscript.js\";\nexport const resources = {\n  \"userscript.js\": _js,\n};\n","// Block Pinning\n// By: SharkPool\n\nexport default async function({ addon, msg }) {\n  const Blockly = await addon.tab.traps.getBlockly();\n  const vm = addon.tab.traps.vm;\n\n  const categoryIcon = \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI3MC42OTIiIGhlaWdodD0iNzAuNjkyIiB2aWV3Qm94PSIwIDAgNzAuNjkyIDcwLjY5MiI+PHBhdGggZD0iTTAgMzUuMzQ2QzAgMTUuODI1IDE1LjgyNSAwIDM1LjM0NiAwczM1LjM0NiAxNS44MjUgMzUuMzQ2IDM1LjM0Ni0xNS44MjUgMzUuMzQ2LTM1LjM0NiAzNS4zNDZTMCA1NC44NjcgMCAzNS4zNDYiIGZpbGw9IiNjNWJmOTYiLz48cGF0aCBkPSJNNC42NTYgMzUuMzQ2YzAtMTYuOTUgMTMuNzQtMzAuNjkgMzAuNjktMzAuNjlzMzAuNjkgMTMuNzQgMzAuNjkgMzAuNjktMTMuNzQgMzAuNjktMzAuNjkgMzAuNjktMzAuNjktMTMuNzQtMzAuNjktMzAuNjkiIGZpbGw9IiNmZmY3YzIiLz48cGF0aCBkPSJNNDguOTU2IDQ0LjAwMyA1MSA1MC4wMmwtNi4wMTctMi4wNDVMMzQuMTY4IDM3LjE2Yy0xLjg3MyAxLjY1NS02LjAwNyA1LjE1MS03LjMwMyA1LjAxOS0yLjM4Ny0uMjQ0LTEuODg5LTIuOTQ3LTIuMDQ4LTUuMzc2LS4xNTgtMi40MyAxLjQ3MS0zLjQ0IDEuNDcxLTMuNDRsLTUuODc5LTUuODhhMi40NSAyLjQ1IDAgMCAxIDAtMy40NjFsNC42MzMtNC42MzNhMi40NSAyLjQ1IDAgMCAxIDMuNDYxIDBsNi4wNyA2LjA3czIuMTQ5LTIuMDAzIDMuOTAyLTJjMS43NTMuMDAyIDUuNjY0LjA3NSA1LjMyMyAyLjAxMy0uMjM1IDEuMzMyLTQuMTExIDUuOTYtNS42MzkgNy43MzV6IiBmaWxsPSIjNDQ1MjczIi8+PC9zdmc+\";\n\n  const category = document.createElementNS(\"http://www.w3.org/1999/xml\", \"category\");\n  category.setAttribute(\"name\", msg(\"pinned\"));\n  category.setAttribute(\"id\", \"pinned\");\n  category.setAttribute(\"colour\", \"#ffffff\");\n  category.setAttribute(\"secondaryColour\", \"#ffffff\");\n  category.setAttribute(\"iconURI\", categoryIcon);\n\n  const gap = document.createElementNS(\"http://www.w3.org/1999/xml\", \"sep\");\n  gap.setAttribute(\"gap\", \"36\");\n\n  let populateInit = 0; // counts up to 3, any 'populate' call while this is less than 3 will update the toolbox\n  let pins = loadPins();\n\n  const autoLoadExtPins = addon.settings.get(\"autoLoadExts\");\n\n  function findExtensionPins() {\n    const extUrls = [];\n\n    const manager = vm.extensionManager;\n    const loadedExts = manager._loadedExtensions;\n    loadedExts.keys().forEach((id) => {\n      if (pins.some(b => b.startsWith(id))) {\n        const meta = loadedExts.get(id);\n\n        if (meta.startsWith(\"extension_\")) {\n          // built-in extension\n          extUrls.push(id);\n        } else {\n          // external extension\n          const index = parseInt(meta.split(\".\")[1]);\n          extUrls.push(manager.workerURLs[index]);\n        }\n      }\n    });\n    return extUrls;\n  }\n\n  function loadPins() {\n    try {\n      const item = localStorage.getItem(\"ADDONS_BLOCK-PINS\");\n      if (!item) return [];\n\n      const testPins = JSON.parse(item);\n      if (Array.isArray(testPins.blocks) && Array.isArray(testPins.exts)) {\n        // load required extensions\n        const manager = vm.extensionManager;\n        for (const ext of testPins.exts) {\n          try {\n            const isURL = new URL(ext);\n            manager.securityManager.canLoadExtensionFromProject(ext).then(isUnsandbox => {\n              manager.loadExtensionURL(ext);\n            });\n          } catch {\n            // not a URL, must be a built-in\n            manager.loadExtensionIdSync(ext);\n          }\n        }\n        return testPins.blocks;\n      } else {\n        return [];\n      }\n    } catch {\n      console.warn(\"Malformed Block Pins!\");\n      localStorage.removeItem(\"ADDONS_BLOCK-PINS\");\n      return [];\n    }\n  }\n\n  function storePins() {\n    const requiredExtensions = autoLoadExtPins ? findExtensionPins() : [];\n    localStorage.setItem(\n      \"ADDONS_BLOCK-PINS\", JSON.stringify({\n        blocks: pins, exts: requiredExtensions\n      })\n    );\n  }\n\n  const createMenuItem = (text, enabled, callback) => {\n    // so amazing, saves like, 20 lines\n    return { text, enabled, callback };\n  };\n\n  const createLabel = (text) => {\n    const label = document.createElementNS(\"http://www.w3.org/1999/xml\", \"label\");\n    label.setAttribute(\"text\", text);\n    return label;\n  };\n\n  const specifyType = (block) => {\n    let type = block.type;\n    if (type === \"data_variable\" || type === \"data_listcontents\") {\n      type += \"||v||\" + block.getVars()[0];\n    } else if (type === \"procedures_call\") {\n      type += \"||p||\" + block.getProcCode();\n    }\n    return type;\n  };\n\n  const getBlockByType = (type, ws) => {\n    const typeMeta = type.split(\"||\");\n    const blocks = Object.values(ws.blockDB_);\n    if (typeMeta.length === 1) return blocks.find(b => b.type === type);\n    else {\n      const candidates = blocks.filter(b => b.type === typeMeta[0]);\n      for (const test of candidates) {\n        if (typeMeta[1] === \"p\") {\n          if (test.getProcCode() === typeMeta[2]) return test;\n        }\n        if (typeMeta[1] === \"v\") {\n          if (test.getVars()[0] === typeMeta[2]) return test;\n        }\n      }\n      return null;\n    }\n  };\n\n  const populateCategory = () => {\n    category.innerHTML = \"\"; // flush out blocks\n\n    if (pins.length) {\n      const flyoutWS = Blockly.mainWorkspace.getFlyout().workspace_;\n      const blocksXML = [];\n      let successes = 0;\n      for (const type of pins) {\n        const block = getBlockByType(type, flyoutWS);\n        if (block) {\n          successes++;\n          blocksXML.push(Blockly.Xml.blockToDom(block));\n        } else {\n          console.warn(\"Pins Addon -- Could not find block with type: \" + type);\n        }\n      }\n\n      if (blocksXML.length === 0) blocksXML.push(createLabel(msg(\"no_pinned_blocks\")));\n      else if (successes !== pins.length) blocksXML.push(createLabel(msg(\"some_pins_could_not_load\")));\n      category.append(...blocksXML, gap);\n    } else {\n      category.append(createLabel(msg(\"no_pinned_blocks\")), gap);\n    }\n  }\n\n  const updatePinCategory = () => {\n    populateCategory();\n    const toolbox = Blockly.mainWorkspace.getToolbox();\n    toolbox.populate_(toolbox.workspace_.options.languageTree);\n\n    storePins();\n  };\n\n  const toggleBlockPin = (block, isPinning, forceOrder) => {\n    const oldLength = pins.length;\n    const type = specifyType(block);\n    const index = pins.indexOf(type);\n\n    if (isPinning) {\n      switch (forceOrder) {\n        case \"top\":\n          pins.splice(index, 1);\n          pins = [type, ...pins];\n          break;\n        case \"bottom\":\n          pins.splice(index, 1);\n          pins.push(type);\n          break;\n        case \"category\": {\n          const toolbox = Blockly.mainWorkspace.getToolbox();\n          const flyoutWS = Blockly.mainWorkspace.getFlyout().workspace_;\n          const categories = toolbox.categoryMenu_.categories_.map(c => c.id_);\n\n          const getCategoryInd = (id) => {\n            const block = getBlockByType(id, flyoutWS);\n            let cateID = block.category_;\n            if (cateID === \"data\") cateID = \"variables\";\n            else if (cateID === \"data-lists\") cateID = \"lists\";\n            else if (cateID === null) cateID = \"myBlocks\";\n            return categories.indexOf(cateID);\n          };\n\n          pins = pins.sort((a, b) => getCategoryInd(a) - getCategoryInd(b));\n          break;\n        }\n        default:\n          if (index === -1) pins.push(type);\n      }\n    } else if (index > -1) {\n      pins.splice(index, 1);\n    }\n\n    if (oldLength !== pins.length || forceOrder) updatePinCategory();\n  };\n\n  const ogShowCtxMenu = Blockly.BlockSvg.prototype.showContextMenu_;\n  Blockly.BlockSvg.prototype.showContextMenu_ = function(e) {\n    if (this.workspace.options.readOnly || !this.contextMenu) return;\n\n    let shouldPatchClasses = false;\n\n    // Save the current block in a variable for use in closures.\n    var block = this;\n    var menuOptions = [];\n    if (this.isDeletable() && this.isMovable() && block.isInFlyout) {\n      if (pins.includes(specifyType(block))) {\n        shouldPatchClasses = true;\n        menuOptions.push(\n          createMenuItem(msg(\"move_to_top\"), true, () => toggleBlockPin(block, true, \"top\")),\n          createMenuItem(msg(\"move_to_bottom\"), true, () => toggleBlockPin(block, true, \"bottom\")),\n          createMenuItem(msg(\"organize_by_category\"), true, () => toggleBlockPin(\"\", true, \"category\")),\n          createMenuItem(msg(\"pin\"), false, () => {}),\n          createMenuItem(msg(\"unpin\"), true, () => toggleBlockPin(block, false))\n        );\n      } else {\n        menuOptions.push(\n          createMenuItem(msg(\"pin\"), true, () => toggleBlockPin(block, true)),\n          createMenuItem(msg(\"unpin\"), false, () => {})\n        );\n      }\n\n      menuOptions.push(createMenuItem(msg(\"unpin_all\"), pins.length, () => {\n        pins = [];\n        updatePinCategory();\n      }));\n    } else {\n      ogShowCtxMenu.call(this, e);\n      return;\n    }\n\n    if (this.customContextMenu) this.customContextMenu(menuOptions);\n    Blockly.ContextMenu.show(e, menuOptions, this.RTL);\n    Blockly.ContextMenu.currentBlock = this;\n\n    if (shouldPatchClasses) {\n      // since we have to patch the context meny generator, we cant use\n      // addon apis to fancify the menu. So, recreate it here:\n      const menuItems = Blockly.WidgetDiv.DIV.querySelectorAll(`div[class^=\"goog-menuitem-content\"]`);\n      /* Unpin item */\n      menuItems[3].parentNode.style.borderTop = \"1px solid rgba(0, 0, 0, 0.15)\";\n    };\n  }\n\n  const ogPopulate = Blockly.Toolbox.CategoryMenu.prototype.populate;\n  Blockly.Toolbox.CategoryMenu.prototype.populate = function(newTree) {\n    if (populateInit < 3) {\n      populateInit++;\n      setTimeout(() => {\n        // 1 second is a good buffer\n        populateCategory();\n        const toolbox = Blockly.mainWorkspace.getToolbox();\n        if (!toolbox) return;\n        toolbox.populate_(toolbox.workspace_.options.languageTree);\n      }, 1000);\n    }\n\n    newTree.insertBefore(category, newTree.firstElementChild);\n    ogPopulate.call(this, newTree);\n  }\n\n  vm.runtime.on(\"PROJECT_LOADED\", () => {\n    populateInit = 0;\n  });\n  if (!autoLoadExtPins) vm.runtime.on(\"EXTENSION_ADDED\", () => {\n    populateInit = 2;\n  });\n  vm.runtime.on(\"EXTENSION_REMOVED\", (extId) => {\n    // remove blocks in the removed extension from pins\n    pins = pins.filter((t) => !t.startsWith(extId));\n\n    populateInit = 2;\n  });\n  addon.self.addEventListener(\"disabled\", () => {\n    localStorage.removeItem(\"ADDONS_BLOCK-PINS\");\n  });\n}\n","/* generated by pull.js */\nimport _js from \"./userscript.js\";\nimport _css from \"!css-loader!./userstyle.css\";\nexport const resources = {\n  \"userscript.js\": _js,\n  \"userstyle.css\": _css,\n};","import icon from \"!../../../lib/tw-recolor/build!./bookmark.svg\";\n\nexport default async ({ addon, msg, console }) => {\n  const Blockly = await addon.tab.traps.getBlockly();\n  const vm = addon.tab.traps.vm;\n\n  const BOOKMARK_MAGIC = \" // _bookmark_\";\n  const BOOKMARK_COMMENT_HEADER = msg(\"comment-header\");\n\n  // Get current editing target\n  const getEditingTarget = () => {\n    return vm.runtime.getEditingTarget();\n  };\n\n  // Find the bookmark comment in the current target\n  const findBookmarkComment = () => {\n    const target = getEditingTarget();\n    if (!target || !target.comments) return null;\n\n    const comments = Object.values(target.comments);\n    for (const comment of comments) {\n      if (comment.text.includes(BOOKMARK_MAGIC)) {\n        return comment;\n      }\n    }\n    return null;\n  };\n\n  // Parse bookmark data from comment\n  const parseBookmarkComment = () => {\n    const comment = findBookmarkComment();\n    if (!comment) return [];\n\n    const lineWithMagic = comment.text.split(\"\\n\").find((i) => i.endsWith(BOOKMARK_MAGIC));\n    if (!lineWithMagic) {\n      console.warn(\"Bookmark comment does not contain valid line\");\n      return [];\n    }\n\n    const jsonText = lineWithMagic.substr(0, lineWithMagic.length - BOOKMARK_MAGIC.length);\n    try {\n      return JSON.parse(jsonText);\n    } catch (e) {\n      console.warn(\"Bookmark comment has invalid JSON\", e);\n      return [];\n    }\n  };\n\n  // Save bookmark data to comment\n  const saveBookmarkComment = (bookmarks) => {\n    const text = `${BOOKMARK_COMMENT_HEADER}\\n${JSON.stringify(bookmarks)}${BOOKMARK_MAGIC}`;\n    const existingComment = findBookmarkComment();\n\n    if (existingComment) {\n      existingComment.text = text;\n    } else {\n      const target = getEditingTarget();\n      if (!target) return;\n\n      target.createComment(\n        Math.random() + \"\",\n        null,\n        text,\n        50,\n        50,\n        350,\n        150,\n        false\n      );\n    }\n\n    // Notify project changed\n    vm.runtime.emitProjectChanged();\n    if (vm.editingTarget === vm.runtime.getTargetForStage()) {\n      vm.emitWorkspaceUpdate();\n    }\n  };\n\n  // Get the main workspace (similar to Utils.getWorkspace)\n  const getWorkspace = () => {\n    const currentWorkspace = Blockly.getMainWorkspace();\n    if (currentWorkspace.getToolbox()) {\n      return currentWorkspace;\n    }\n    return Blockly.getMainWorkspace();\n  };\n\n  // Get current workspace state\n  const getWorkspaceState = () => {\n    const workspace = getWorkspace();\n    const s = workspace.getMetrics();\n    return {\n      viewLeft: s.viewLeft,\n      viewTop: s.viewTop,\n      scale: workspace.scale,\n      timestamp: Date.now()\n    };\n  };\n\n  // Restore workspace state (similar to NavigationHistory.goBack)\n  const restoreWorkspaceState = (state) => {\n    const workspace = getWorkspace();\n\n    // First set the scale\n    workspace.setScale(state.scale);\n\n    // Use requestAnimationFrame to ensure the workspace is updated after scale change\n    requestAnimationFrame(() => {\n      const s = workspace.getMetrics();\n\n      // Then restore the scroll position\n      // Calculate scroll position based on current contentLeft/contentTop\n      const sx = state.viewLeft - s.contentLeft;\n      const sy = state.viewTop - s.contentTop;\n\n      workspace.scrollbar.set(sx, sy);\n\n      // Hide Blockly floating elements\n      Blockly.hideChaff();\n    });\n  };\n\n  let bookmarkButton = null;\n\n  // Check if VSCodeLayout is enabled\n  const isVSCodeLayout = () => {\n    try {\n      const settings = JSON.parse(localStorage.getItem('AESettings'));\n      return settings && settings.EnableVSCodeLayout;\n    } catch (e) {\n      return false;\n    }\n  };\n\n  // Create bookmark modal\n  const createBookmarkModal = () => {\n    const { backdrop, container, content, closeButton, remove } = addon.tab.createModal(msg(\"bookmark-title\"), {\n      isOpen: true,\n      useEditorClasses: true\n    });\n    container.classList.add(\"sa-bookmark-modal\");\n    content.classList.add(\"sa-bookmark-modal-content\");\n    \n    // Check theme after a small delay to ensure DOM is ready\n    setTimeout(() => {\n      // The theme is handled by CSS variables, no need for JavaScript detection\n      console.log('Bookmark plugin - Modal opened');\n    }, 10);\n\n    // Create bookmark list\n    const bookmarkList = document.createElement(\"div\");\n    bookmarkList.className = \"sa-bookmark-list\";\n\n    let bookmarks = parseBookmarkComment();\n\n    const renderBookmarks = () => {\n      bookmarkList.innerHTML = \"\";\n      bookmarks = parseBookmarkComment();\n\n      if (bookmarks.length === 0) {\n        const emptyMessage = document.createElement(\"div\");\n        emptyMessage.className = \"sa-bookmark-empty\";\n        emptyMessage.textContent = msg(\"no-bookmarks\");\n        bookmarkList.appendChild(emptyMessage);\n        return;\n      }\n\n      bookmarks.forEach((bookmark, index) => {\n        const bookmarkItem = document.createElement(\"div\");\n        bookmarkItem.className = \"sa-bookmark-item\";\n\n        const bookmarkInfo = document.createElement(\"div\");\n        bookmarkInfo.className = \"sa-bookmark-info\";\n\n        const bookmarkName = document.createElement(\"span\");\n        bookmarkName.className = \"sa-bookmark-name\";\n        bookmarkName.textContent = bookmark.name || msg(\"bookmark-default-name\", { index: index + 1 });\n        bookmarkName.title = msg(\"edit-bookmark-hint\");\n\n        // Make bookmark name editable\n        bookmarkName.addEventListener(\"click\", () => {\n          const input = document.createElement(\"input\");\n          input.type = \"text\";\n          input.value = bookmark.name || msg(\"bookmark-default-name\", { index: index + 1 });\n          input.className = \"sa-bookmark-name-input\";\n          input.classList.add(addon.tab.scratchClass(\"input_input-form\"));\n\n          const saveEdit = () => {\n            const newName = input.value.trim();\n            bookmark.name = newName || null;\n            saveBookmarkComment(bookmarks);\n            bookmarkName.textContent = newName || msg(\"bookmark-default-name\", { index: index + 1 });\n          };\n\n          input.addEventListener(\"blur\", saveEdit);\n          input.addEventListener(\"keydown\", (e) => {\n            if (e.key === \"Enter\") {\n              saveEdit();\n            } else if (e.key === \"Escape\") {\n              bookmarkName.textContent = bookmark.name || msg(\"bookmark-default-name\", { index: index + 1 });\n            }\n          });\n\n          bookmarkName.innerHTML = \"\";\n          bookmarkName.appendChild(input);\n          input.focus();\n          input.select();\n        });\n\n        const bookmarkTime = document.createElement(\"span\");\n        bookmarkTime.className = \"sa-bookmark-time\";\n        bookmarkTime.textContent = new Date(bookmark.timestamp).toLocaleString();\n\n        bookmarkInfo.appendChild(bookmarkName);\n        bookmarkInfo.appendChild(bookmarkTime);\n\n        const bookmarkActions = document.createElement(\"div\");\n        bookmarkActions.className = \"sa-bookmark-actions\";\n\n        const jumpButton = document.createElement(\"button\");\n        jumpButton.className = \"sa-bookmark-action-button\";\n        jumpButton.textContent = msg(\"jump\");\n        jumpButton.addEventListener(\"click\", () => {\n          restoreWorkspaceState(bookmark.state);\n          remove();\n        });\n\n        const deleteButton = document.createElement(\"button\");\n        deleteButton.className = \"sa-bookmark-action-button sa-bookmark-delete\";\n        deleteButton.textContent = msg(\"delete\");\n        deleteButton.addEventListener(\"click\", () => {\n          bookmarks.splice(index, 1);\n          saveBookmarkComment(bookmarks);\n          renderBookmarks();\n        });\n\n        bookmarkActions.appendChild(jumpButton);\n        bookmarkActions.appendChild(deleteButton);\n\n        bookmarkItem.appendChild(bookmarkInfo);\n        bookmarkItem.appendChild(bookmarkActions);\n        bookmarkList.appendChild(bookmarkItem);\n      });\n    };\n\n    renderBookmarks();\n\n    // Add bookmark form\n    const addBookmarkForm = document.createElement(\"div\");\n    addBookmarkForm.className = \"sa-bookmark-add-form\";\n\n    const nameLabel = document.createElement(\"label\");\n    nameLabel.textContent = msg(\"bookmark-name\");\n\n    const nameInput = document.createElement(\"input\");\n    nameInput.type = \"text\";\n    nameInput.placeholder = msg(\"bookmark-name-placeholder\");\n    nameInput.className = addon.tab.scratchClass(\"input_input-form\");\n\n    const addButton = document.createElement(\"button\");\n    addButton.textContent = msg(\"add-bookmark\");\n    addButton.className = addon.tab.scratchClass(\"prompt_ok-button\");\n\n    addButton.addEventListener(\"click\", () => {\n      const name = nameInput.value.trim();\n      const newBookmark = {\n        name: name || null,\n        state: getWorkspaceState(),\n        timestamp: Date.now()\n      };\n      bookmarks.push(newBookmark);\n      saveBookmarkComment(bookmarks);\n      nameInput.value = \"\";\n      renderBookmarks();\n    });\n\n    addBookmarkForm.appendChild(nameLabel);\n    addBookmarkForm.appendChild(nameInput);\n    addBookmarkForm.appendChild(addButton);\n\n    content.appendChild(bookmarkList);\n    content.appendChild(addBookmarkForm);\n\n    // Close handlers\n    backdrop.addEventListener(\"click\", () => remove());\n    closeButton.addEventListener(\"click\", () => remove());\n\n    // Close on Escape\n    const escapeHandler = (e) => {\n      if (e.key === \"Escape\") {\n        remove();\n        document.removeEventListener(\"keydown\", escapeHandler);\n      }\n    };\n    document.addEventListener(\"keydown\", escapeHandler);\n  };\n\n  // Create bookmark button\n  const createBookmarkButton = async () => {\n    const VSCodeLayout = JSON.parse(localStorage.getItem('AESettings')).EnableVSCodeLayout;\n\n    // 检测是否在 VSCodeLayout 下\n    const tabBar = await addon.tab.waitForElement('[class*=\"react-tabs_react-tabs__tab-list\"]', {\n      markAsSeen: true\n    });\n\n    // 尝试查找 SPA 插件的位置\n    const spaButton = document.querySelector('.sa-analyze-button');\n    let targetElement;\n\n    if (spaButton) {\n      // 如果 SPA 按钮存在，在其右边添加按钮\n      targetElement = spaButton.parentElement;\n    } else {\n      // 否则，使用标签栏\n      targetElement = tabBar;\n    }\n\n    if (!targetElement) return;\n\n    bookmarkButton = document.createElement('button');\n    bookmarkButton.className = addon.tab.scratchClass('menu-bar_menu-bar-button', {\n      others: 'sa-bookmark-button'\n    });\n\n    if (VSCodeLayout) {\n      // VSCodeLayout 下使用 SVG 图标\n      const img = document.createElement('img');\n      img.src = icon();\n      img.style.filter = \"grayscale(100%)\";\n      img.style.width = '20px';\n      img.style.height = '20px';\n      img.style.marginTop = '5px';\n      img.alt = msg(\"bookmark-button\");\n      bookmarkButton.appendChild(img);\n    } else {\n      // 普通布局下使用文字\n      bookmarkButton.textContent = msg(\"bookmark-button\");\n    }\n    bookmarkButton.title = msg(\"bookmark-button-tooltip\");\n\n    // 禁用时隐藏按钮\n    addon.tab.displayNoneWhileDisabled(bookmarkButton);\n\n    bookmarkButton.addEventListener(\"click\", () => {\n      createBookmarkModal();\n    });\n\n    // 将按钮添加到目标位置\n    if (VSCodeLayout) {\n      // VSCodeLayout 下，按钮应该插入到标签栏（TabList）中\n      tabBar.appendChild(bookmarkButton);\n    } else if (spaButton) {\n      // 在 SPA 按钮右边添加\n      if (spaButton.nextSibling) {\n        targetElement.insertBefore(bookmarkButton, spaButton.nextSibling);\n      } else {\n        targetElement.appendChild(bookmarkButton);\n      }\n    } else {\n      // 在标签栏最右方添加\n      targetElement.appendChild(bookmarkButton);\n    }\n  };\n\n  // Create the button\n  await createBookmarkButton();\n};","\n    const original = \"<svg width=\\\"24\\\" height=\\\"24\\\" viewBox=\\\"0 0 24 24\\\" fill=\\\"#855cd6\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n  <path d=\\\"M19 21L12 16L5 21V5C5 3.89543 5.89543 3 7 3H17C18.1046 3 19 3.89543 19 5V21Z\\\" stroke=\\\"#855cd6\\\" stroke-width=\\\"2\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\"/>\\n</svg>\\n\";\n\n    const getSRC = () => {\n        const recolored = typeof Recolor === 'object' ? (\n            original.replace(/#855cd6/gi, Recolor.primary)\n        ) : original;\n        return 'data:image/svg+xml;,' + encodeURIComponent(recolored);\n    };\n\n    export default getSRC;\n"],"mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACPA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACJA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxRA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/WA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;A","sourceRoot":""}